{"Algorithm/Tree/세그먼트-트리":{"title":"세그먼트 트리","links":[],"tags":["알고리즘","트리"],"content":"세그먼트 트리 §\n\nSegment Tree\n구간을 저장하기 위한 이진 트리\n\n주어진 전체에서 특정 구간에 대한 연산을 구해야 하는 경우, 가장 처음 모든 합을 구해 놓고 계산하는 방법이 있을 수 있다. 세그먼트 트리는 여러 개의 데이터가 연속적으로 존재할 때 특정한 범위의 데이터의 합을 구하는 빠른 방법이다.\n리프노드는 배열의 순수한 값 그 자체를 가지며, 나머지 노드에는 해당 자식들의 합이 저장되어 있다. 이런 과정을 거치면 루트 노드는 배열 전체 구간의 합을 가지게 된다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n변수크기배열n트리의 높이ceil(log2(n)세그먼트 트리의 크기2^(트리의 높이 + 1)\n세그먼트 트리 구현은 다음의 과정을 따른다.\n\n트리 초기화\n갱신 (update)\n쿼리 / 합 (sum)\n\n세그먼트 트리 구현 §\nwith C++// 초기화\nvector&lt;long long&gt; arr;\nvector&lt;long long&gt; tree;\n \nlong long init(int node, int start, int end) {\n\tif (start == end) return tree[node] = arr[start];\n\tint mid = (start + end) / 2;\n\treturn tree[node] = init(node * 2*, start, mid) + init(node * 2 + 1, mid + 1, end);\n}\n \n// 업데이트\nvoid update(int node, int start, int end, int index, long long diff) {\n    if (!(start &lt;= index &amp;&amp; index &lt;= end)) return;\n    tree[node] += diff;\n    if (start != end) {\n        int mid = (start + end) / 2;\n        update(node * 2, start, mid, index, diff);\n        update(node * 2 + 1, mid + 1, end, index, diff);\n    }\n}\n \n// 합\nlong long sum(int node, int start, int end, int left, int right) {\n    if (left &gt; end || right &lt; start) return 0;\n    if (left &lt;= start &amp;&amp; end &lt;= right) return tree[node];\n    int mid = (start + end) / 2;\n    return sum(node * 2, start, mid, left, right) + sum(node * 2 + 1, mid + 1, left, right);\n}\nwith java \n "},"Algorithm/Tree/최소-스패닝-트리":{"title":"최소 스패닝 트리","links":[],"tags":["알고리즘","트리"],"content":"최소 신장 트리 §\n\nMinimun Spanning Tree (MST)\n모든 정점을 잇지만 사이클이 없는 부분 그래프\n\n하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 의미한다. 최소한의 비용으로 신장 트리를 찾는 것이 MST 알고리즘이다.\n그루스칼 (Kruskal) §\n\n그리디 알고리즘의 일종으로 분류\n\n모든 간선에 대하여 정렬을 수행한 뒤, 가장 거리가 짧은 간선부터 집합에 포함한다. 사이클을 발생하는 경우는 집합에서 제외한다. 일종의 트리 구조이므로 최종적으로 만들어지는 신장 트리에 포함되는 간선의 개수가 노드의 개수 + 1과 같다.\n그루스칼 알고리즘 구현 §\n// 정점이 7개인 그래프로 예시\nconst int V = 7;\nvector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;graph;\n \nstruct Edge {\n    int src, dest, weight;\n};\n \n// 노드 x의 부모를 찾는 함수\nint find(vector&lt;int &amp;parent, int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent, parent[x]);\n    }\n    return parent[x];\n}\n \n// 두 노드가 속한 집합을 합치는 함수\nvoid merge(vector&lt;int&gt;&amp;parent, vector&lt;int&gt;&amp; rank, int u, int v) {\n    u = find(parent, u);\n    v = find(parent, v);\n    if (rank[u] &gt; rank[v]) {\n        swap(u, v);\n    }\n    parent[u] = v;\n    if(rank[u] == rank[v]) {\n        rank[v]++;\n    }\n}\n \n// 그루스칼 알고리즘\nvector&lt;Edge&gt; kruskal() {\n    // 그래프의 간선을 모두 추출한 뒤, 가중치를 기준으로 오름차순으로 정렬\n    vector&lt;Edge&gt; edges;\n    vector&lt;int&gt;parent(V);\n    vector&lt;int&gt;rank(V);\n \n    for(int = 0; i &lt; V; ++i) {\n        // 맨 처음 부모는 자기 자신으로 초기화\n        parent[i] = i;\n        rank[i] = 1;\n        for (auto&amp; edge : graph[i]) {\n            edges.push_back({i, edge.first, edge.second});\n        }\n    }\n    // 가중치를 기준으로 정렬\n    sort(edges.begin(), edges.end(), [](Edge x, Edge y) {\n        retrun x.weight &lt; y.weight;\n    })\n \n    // 간선을 하나씩 선택하며, 그루스칼 알고리즘 적용\n    vector&lt;Edge&gt; result;\n    for (auto&amp; edge : edges) {\n        int u = edge.src, v = edge,deset, weight = edge.weight;\n        if (find(parent, u) != find(parent, v)) {\n            merge(parent, rank, u, v);\n            result.push_back(edge);\n        }\n    }\n    return result;\n}\n \nint main() {\n    vector&lt;Edge&gt; result = kruskal();\n    return 0;\n}"},"Computer-Science/Database/n+1":{"title":"N + 1 문제","links":[],"tags":["database"],"content":"N+1 문제란? §\n연관 관계에서 발생하는 이슈로 연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수(n) 만큼 연관 관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오게 된다. 즉, 의도하지 않은 n번의 쿼리가 추가적으로 발생한다.\n\n\n                  \n                  미완 \n                  \n                \n"},"index":{"title":"Welcome to DooDoo's Digital Garden","links":[],"tags":[],"content":"이 페이지는 제텔카스텐 기법을 준수하여 옵시디언에서 작성되었습니다.\n전체 두뇌 연결 §\n\n\n                  \n                  Warning \n                  \n                \n추후 구현 예정\n\n\n\n                  \n                  Tip \n                  \n                \ngit pages에 quartz를 배포하고 관리하는 방법은 quartz 4.0와 Quartz v4를 참고\n\n\n\n                  \n                  추후 구현 기능 예정 \n                  \n                  \n                \n                \n\nTags 만 모아서 보기 (현재 태그를 누르면 tag의 글들이 보임) &gt;&gt; 취소 그래프 뷰가 더러워 질 수 있음\n\n\n|te"}}