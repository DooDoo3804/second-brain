{"Algorithm/Tree/세그먼트-트리":{"title":"세그먼트 트리","links":[],"tags":["알고리즘","트리"],"content":"세그먼트 트리 §\n\nSegment Tree\n구간을 저장하기 위한 이진 트리\n\n주어진 전체에서 특정 구간에 대한 연산을 구해야 하는 경우, 가장 처음 모든 합을 구해 놓고 계산하는 방법이 있을 수 있다. 세그먼트 트리는 여러 개의 데이터가 연속적으로 존재할 때 특정한 범위의 데이터의 합을 구하는 빠른 방법이다.\n리프노드는 배열의 순수한 값 그 자체를 가지며, 나머지 노드에는 해당 자식들의 합이 저장되어 있다. 이런 과정을 거치면 루트 노드는 배열 전체 구간의 합을 가지게 된다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n변수크기배열n트리의 높이ceil(log2(n)세그먼트 트리의 크기2^(트리의 높이 + 1)\n세그먼트 트리 구현은 다음의 과정을 따른다.\n\n트리 초기화\n갱신 (update)\n쿼리 / 합 (sum)\n\n세그먼트 트리 구현 §\nwith C++// 초기화\nvector&lt;long long&gt; arr;\nvector&lt;long long&gt; tree;\n \nlong long init(int node, int start, int end) {\n\tif (start == end) return tree[node] = arr[start];\n\tint mid = (start + end) / 2;\n\treturn tree[node] = init(node * 2*, start, mid) + init(node * 2 + 1, mid + 1, end);\n}\n \n// 업데이트\nvoid update(int node, int start, int end, int index, long long diff) {\n    if (!(start &lt;= index &amp;&amp; index &lt;= end)) return;\n    tree[node] += diff;\n    if (start != end) {\n        int mid = (start + end) / 2;\n        update(node * 2, start, mid, index, diff);\n        update(node * 2 + 1, mid + 1, end, index, diff);\n    }\n}\n \n// 합\nlong long sum(int node, int start, int end, int left, int right) {\n    if (left &gt; end || right &lt; start) return 0;\n    if (left &lt;= start &amp;&amp; end &lt;= right) return tree[node];\n    int mid = (start + end) / 2;\n    return sum(node * 2, start, mid, left, right) + sum(node * 2 + 1, mid + 1, left, right);\n}\nwith java \n "},"Algorithm/Tree/최소-스패닝-트리":{"title":"최소 스패닝 트리","links":[],"tags":["알고리즘","트리"],"content":"최소 신장 트리 §\n\nMinimun Spanning Tree (MST)\n모든 정점을 잇지만 사이클이 없는 부분 그래프\n\n하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 의미한다. 최소한의 비용으로 신장 트리를 찾는 것이 MST 알고리즘이다.\n그루스칼 (Kruskal) §\n\n그리디 알고리즘의 일종으로 분류\n\n모든 간선에 대하여 정렬을 수행한 뒤, 가장 거리가 짧은 간선부터 집합에 포함한다. 사이클을 발생하는 경우는 집합에서 제외한다. 일종의 트리 구조이므로 최종적으로 만들어지는 신장 트리에 포함되는 간선의 개수가 노드의 개수 + 1과 같다.\n그루스칼 알고리즘 구현 §\n// 정점이 7개인 그래프로 예시\nconst int V = 7;\nvector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;graph;\n \nstruct Edge {\n    int src, dest, weight;\n};\n \n// 노드 x의 부모를 찾는 함수\nint find(vector&lt;int &amp;parent, int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent, parent[x]);\n    }\n    return parent[x];\n}\n \n// 두 노드가 속한 집합을 합치는 함수\nvoid merge(vector&lt;int&gt;&amp;parent, vector&lt;int&gt;&amp; rank, int u, int v) {\n    u = find(parent, u);\n    v = find(parent, v);\n    if (rank[u] &gt; rank[v]) {\n        swap(u, v);\n    }\n    parent[u] = v;\n    if(rank[u] == rank[v]) {\n        rank[v]++;\n    }\n}\n \n// 그루스칼 알고리즘\nvector&lt;Edge&gt; kruskal() {\n    // 그래프의 간선을 모두 추출한 뒤, 가중치를 기준으로 오름차순으로 정렬\n    vector&lt;Edge&gt; edges;\n    vector&lt;int&gt;parent(V);\n    vector&lt;int&gt;rank(V);\n \n    for(int = 0; i &lt; V; ++i) {\n        // 맨 처음 부모는 자기 자신으로 초기화\n        parent[i] = i;\n        rank[i] = 1;\n        for (auto&amp; edge : graph[i]) {\n            edges.push_back({i, edge.first, edge.second});\n        }\n    }\n    // 가중치를 기준으로 정렬\n    sort(edges.begin(), edges.end(), [](Edge x, Edge y) {\n        retrun x.weight &lt; y.weight;\n    })\n \n    // 간선을 하나씩 선택하며, 그루스칼 알고리즘 적용\n    vector&lt;Edge&gt; result;\n    for (auto&amp; edge : edges) {\n        int u = edge.src, v = edge,deset, weight = edge.weight;\n        if (find(parent, u) != find(parent, v)) {\n            merge(parent, rank, u, v);\n            result.push_back(edge);\n        }\n    }\n    return result;\n}\n \nint main() {\n    vector&lt;Edge&gt; result = kruskal();\n    return 0;\n}"},"Algorithm/Tree/트라이":{"title":"트라이","links":[],"tags":["알고리즘","트리"],"content":"트라이 §\n\nTrie\n검색 트리의 일종\n\n트라이는 문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조이다. 트라이는 문자열의 접두사(Prefix)를 이용하여 트리를 구성하므로, 특히 문자열 검색에 있어 유용하다. 이는 흔히 볼 수 있는 자동완성 기능, 사전 검색에서 사용된다. 트라이는 Prefix Tree, Retieval Tree 라고도 불린다. Radix Tree는 일반적인 트라이의 메모리 효율성을 더 좋게 만든 자료구조이다.\n트라이의 구성 §\n\n각 노드는 문자를 저장하는데 사용되는 노드\n루트 노드부터 시작하여 문자열을 표현\n각 노드는 해당 노드까지의 문자열(prefix)를 나타내며, 단어의 끝을 표시하는 플래그를 가질 수 있음\n자식 노드는 해당 문자 다음에 나타날 수 있는 문자를 저장하는 데 사용됨\n\n\n트라이의 구현 §\nwith java/*\n\t트라이 노드\n\t내부 자식(children)을 HashMap으로써 가짐\n*/\n \nstatic class TrieNode {\n\tMap&lt;Character, TrieNode&gt; children;\n\tboolean isWord;\n\tint count;\n\tpublic TrieNode() {\n\t\tchildren = new HashMap&lt;&gt;();\n\t\tisWord = false;\n\t\tcount = 0;\n\t}\n}\n/*\n\t트라이 클래스\n\t트리를 구성하는 isert, 단어를 찾는 search로 구성\n*/\nstatic class Trie {\n\tTrieNode root;\n\tpublic Trie() {\n\t\troot = new TrieNode();\n\t}\n\tpublic void insert(String word) {\n\t\tTrieNode curr = root;\n\t\tfor (char c : word.toCharArray()) {\n\t\t\tcurr.children.putIfAbsent(c, new TrieNode());\n\t\t\tcurr = curr.children.get(c);\n\t\t\tcurr.count++;\n\t\t}\n\t\tcurr.isWord = true;\n\t}\n\tpublic int search(String query) {\n\t\tTrieNode curr = root;\n\t\tint count = 0;\n\t\tfor (char c : query.toCharArray()) {\n\t\t\tif (!curr.children.containsKey(c)) break;\n\t\t\tcurr = curr.children.get(c);\n\t\t\tcount++;\n\t\t\tif (curr.count == 1) break;\n\t\t}\n\t\treturn count;\n\t}\n}"},"Computer-Science/Computer-structure-&-OS/ALU":{"title":"ALU와 제어장치","links":[],"tags":["혼공컴"],"content":"ALU §\nALU(Arithmetic Logic Unit)은 컴퓨터 내부에서 수행되는 대부분의 연산을 담당하기 때문에 피연산자와 수행할 연산이 필요하다. ALU는 레지스터를 통해 피연산자를 받고, 제어장치로부터 수행할 연산을 알려주는 제어신호를 받는다. 받아들인 정보로 산술 연산, 논리 연산 등 다양한 연산을 수행한다.\nCPU가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 느리다. 그렇기에 결괏값을 메모리가 아닌 레지스터에 우선적으로 저장한다. ALU는 계산 결과와 더불어 플래그를 내보낸다. 연산 결과가 음수이거나 결괏값이 레지스터보다 큰 경우 추가적인 정보를 플래그를 통해 전달한다. 이런 플래그들은 플래그 레지스터에 저장된다.\n\n\n                  \n                  Note \n                  \n                \n연산 결과가 담을 레지스터보다 큰 경우를 오버플로우(overflow)라고 한다.\n\n제어 장치 §\n\n제어 신호를 내보내고, 명령어를 해석하는 부분이다. 제어 장치가 받는 정보는 다음과 같다.\n\n클럭 신호: clock은 시간 단위이다. 클럭 주기가 존재한다.\n해석해야 할 명령어:  이 명령어는 명령어 레지스터에 저장된다. 이 래자스터로부터 해석할 명령어를 받아 해석한 뒤, 제어 신호를 발생시켜 부품들에게 전달한다.\n플래그 레지스터 속 플래그 값: ALU 연산으로 생긴 플래그를 받아들여 이를 참고한다.\n시스템 버스, 제어 버스로 전달된 신호: 외부 입출력 장치를 통해 들어온 신호를 받아들이기도 한다.\n\n제어 장치가 CPU 외부에 제어 신호를 전달한다는 것은 제어 버스로 제어 신호를 보내는 것이다. 만약 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰고 싶다면 메모리로 제어 신호를 보낸다. 제어장치는 크게 ALU에 전달하거나 레지스터에 신호를 전달한다. ALU에는 수행할 연산을 지시하기 위해, 레지스터에는 레지스터 간에 데이터를 이동하거나 레지스터에 저장된 명령어를 해석하기 위해 제어 신호를 보낸다."},"Computer-Science/Computer-structure-&-OS/RAM":{"title":"RAM의 특징과 종류","links":[],"tags":["혼공컴"],"content":"RAM의 특징 §\n컴퓨터 전원을 끄면 RAM에 저장된 데이터가 모두 사라지기 때문에 휘발성 저장 장치라고 한다.\n\n\n                  \n                  Info \n                  \n                \n하드 디스크나, SSD, CD-ROM, USB 메모리와 같은 보조기억장치는 비휘발성 저장 장치라고 한다.\n\nCPU는 직접 보조기억장치에 접근하지 못한다. 그렇기에 비휘발성 저장 장치에는’보관할 대상’을 저장하고 RAM에는 ‘실행할 대상’을 저장한다. 프로그램을 실행하고 싶다면 보조기억장치에서 프로그램을 꺼내와 RAM에 올려 실행한다. 그렇기에 RAM의 용량이 크다는 것은 많은 프로그램들을 동시에 빠르게 실행하는데 유리하다는 것을 의미한다.\nRAM의 종류 §\nDRAM §\nDynamic RAM의 줄임말, 시간이 지나면 저장된 데이터가 점차 사라지는 RAM이다. 그렇기에 데이터의 소멸을 막기 위해 일정 주기로 데이터를 재활성화 해야 한다.\nSRAM §\nStatic RAM의 줄임말, DRAM과 달리 시간이 지나도 데이터가 변하지 않는다. 주기적으로 데이터를 재활성화할 필요도 없다. SRAM이 DRAM보다 일반적으로 속도도 빠르다. 가격과 전력 소비가 좋지 않기에 일반적인 메모리가 아닌 캐시 메모리에서 사용된다.\nSDRAM §\nSDRAM은 Synchronous Dynamic RAM으로 클럭 신호와 동기화 된 DRAM이다. 클럭 타이밍에 맞춰 CPU와 정보를 주고받을 수 있다.\nDDR SDRAM §\n최근에 가장 흔히 사용되는 RAM이다. 대역폭을 넓혀 속도를 빠르게 만든 SDRAM이다. SDRAM의 2배의 대역폭을 갖는 RAM이다. DDR2 SDRAM은 DDR SDRAM보다 2배의 대역폭을 갖는 RAM이다."},"Computer-Science/Computer-structure-&-OS/레지스터":{"title":"레지스터","links":[],"tags":["혼공컴"],"content":"프로그램 카운터 §\n메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽을 명령어의 주소를 저장한다. 명령어 포인터라고도 불린다.\n명령어 레지스터 §\n해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터이다.\n메모리 주소 레지스터 §\n메모리의 주소를 저장하는 레지스터이다. CPU가 읽고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거친다.\n메모리 버퍼 레지스터 §\n메모리와 주고받을 값을 저장하는 레지스터이다. 즉, 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거친다.\n범용 레지스터 §\n다양한 상황에서 사용할 수 있는 레지스터이다. 범용 레지스터는 데이터와 주소를 모두 저장할 수 있다.\n플래그 레지스터 §\nALU 연산 결과에 따른 플래그를 플래그 레지스터에 저장한다. 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장한다."},"Computer-Science/Computer-structure-&-OS/컴퓨터":{"title":"컴퓨터의 구성","links":["Computer-Science/Computer-structure-&-OS/RAM","Computer-Science/Computer-structure-&-OS/ALU","Computer-Science/Computer-structure-&-OS/레지스터"],"tags":["혼공컴","컴퓨터구조"],"content":"컴퓨터의 4가지 핵심 부품 §\n컴퓨터의 핵심 부품은 중앙처리장치(Central Processing Unit), 주기억장치(main memory), 보조기억장치(secondary memory), 입출력장치(input/ontput device)이다.\n\n\n                  \n                  Info \n                  \n                \n주기억장치는 크게 RAM(Radnom Access Memory)과 ROM(Random Only Memory)이 있지만 메모리 즉 주기억장치는 주로 RAM을 가리킨다.\n\n\n메모리 §\nRAM는 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품이다. 프로그램이 실행되려면 반드시 메모리에 저장되어 있어야 한다.\n이때 컴퓨터가 빠르게 작동하기 위해서는 메모리 속 명령어와 데이터가 정돈되어 있어야 한다. 그래서 메모리에 저장된 값에 빠르고 효율적으로 접근하기 위해 주소(address)라는 개념이 사용된다. 이 주소를 통해 메모리 내 원하는 위치에 접근할 수 있다.\n\nCPU §\nCPU는 컴퓨터의 두뇌이다. 메모리에 저장된 명령어를 읽어 들이고, 읽은 명령어를 해석하고 분석하는 부품이다. CPU는 산술논리연산장치, 레지스터, 제어장치를 통해 동작이 이뤄진다.\n산술논리연산장치 §\nALU(Arithmetic Logic Unit)은 컴퓨터 내부에서 수행되는 대부분의 연산을 담당한다.\n레지스터 §\n레지스터는 CPU내부의 작은 임시 저장 장치로 프로그램을 실행하는 데 필요한 값들을 임시로 저장한다. CPU안에는 여러 개의 레지스터가 존재하며 각각 다른 이름을 갖는다.\n제어장치 §\n제어 장치는 제어 신호(control signal)을 내보내 다른 부품들을 관리하고, 명령어를 해석하는 부품이다.\n\n보조기억장치 §\n보조기억장치는 메모리보다 크기가 크고 컴퓨터의 전원이 꺼져도 저장된 용을 잃지 않는 부품이다. 하드 디스크, SSD, USB 메모리, DVD, CD-ROM 등이 보조기억장치의 일종이다.\n\n입출력장치 §\n입출력장치는 마이크, 스피커, 프린터, 마우스 등 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치를 말한다.\n\n메인보드와 시스템 버스 §\n위의 모든 컴퓨터 부품들은 메인보드에 연결된다. 메인보드 내부에 버스(bus)라는 통로가 존재해 서로 정보를 주고받을 수 있다. 이 중 가장 종요한 버시는 시스템 버스(system bus)이다. 시스템 버스는 주소 버스(address bus), 제어 버스(control bus), 데이터 버스(data bus)로 이루어져 있다."},"Computer-Science/Database/n+1":{"title":"N + 1 문제","links":[],"tags":["database"],"content":"N+1 문제란? §\n연관 관계에서 발생하는 이슈로 연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수(n) 만큼 연관 관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오게 된다. 즉, 의도하지 않은 n번의 쿼리가 추가적으로 발생한다.\n\n\n                  \n                  미완 \n                  \n                \n"},"Framework-&-Programming-Language/Python/Pyinstaller":{"title":"파이썬으로 프로그램 만들기","links":[],"tags":[],"content":"Pyinstaller? §\nPyinstaller를 사용하면 파이썬으로 제작한 프로그램을 간단하게 실행 파일로 만들 수 있다. 실행 파일에 파이썬도 포함되어 있기 때문에 파이썬이 설치되지 않은 pc에서도 실행이 가능하다. 쉘에 아래 명령어를 통해 설치할 수 있다.\npip install pyinstaller\n프로그램으로 만들어 실행할 파이썬 파일을 작성한다. 프로그램을 하나의 파일로 배포하려면 --onefile 옵션을 추가하면 된다. 아래 예시 코드를 준비했다. csv 파일을 읽어 ‘discharge’와 ‘charge’의 마지막 값을 따로 저장하는 코드이다. ‘pandas’ 라이브러리를 사용해 작성했다.\nexportCSV_V2.pyimport os\nimport sys\nimport glob\nimport pandas as pd\nimport datetime\n \ndirectory = os.path.dirname(sys.executable)\nexcel_files = glob.glob(os.path.join(directory, &#039;*.csv&#039;))\nif (excel_files == []):\n    print(&quot;파일 없음&quot;)\nos.makedirs(directory + &#039;/Results_V2&#039;, exist_ok=True)\nfilename = datetime.datetime.now().strftime(&#039;%Y-%m-%d-%H-%M-%S&#039;)\ncharge_list = []\ndischarge_list = []\nfor file in excel_files:\n    df = pd.read_csv(file)\n    for i in range(0, len(df.columns) - 1, 3):\n        cycle = (i // 6) + 1\n        subset = df.iloc[:, i:i+3]\n        last_valid_index = subset.last_valid_index()\n        tail_value = subset.loc[last_valid_index]\n        if (i % 2) :\n            discharge_list.append([cycle, &quot;DisCharge&quot;, tail_value[0]])\n        else :\n            charge_list.append([cycle, &quot;Charge&quot;, tail_value[0]])\ncharge_value_df = pd.DataFrame(charge_list, columns=[&#039;Cycle&#039;, &#039;Mode&#039;, &#039;Capacity&#039;])\ndischarge_value_df = pd.DataFrame(discharge_list, columns=[&#039;Cycle&#039;, &#039;Mode&#039;, &#039;Capacity&#039;])\ncharge_value_df = charge_value_df.sort_values(&#039;Cycle&#039;)\ndischarge_value_df = discharge_value_df.sort_values(&#039;Cycle&#039;)\ncharge_value_df.to_csv(directory + &#039;/Results_V2/&#039; + filename + &#039;_ChargeResult.csv&#039;, index=False, encoding=&#039;cp949&#039;)\ndischarge_value_df.to_csv(directory + &#039;/Results_V2/&#039; + filename + &#039;_DisChargeResult.csv&#039;, index=False, encoding=&#039;cp949&#039;)\npandas를 사용해서 코드를 작성했지만 pyinstaller에 pandas 라이브러리가 추가되지 않았다. 이런 경우에는 --hidden-import={추가할 라이브러리} 옵션으로 번들에 라이브러리를 추가한다.\npyinstaller --onefile --hidden-import=pandas exportCSV_V2.py\n\n작성한 파이썬 파일 외에 spec(옵션 파일)과, dist, build 폴더가 생성된다. 최종 프로그램은 dist 폴더 안에 파일 하나로 통합되어 있다."},"index":{"title":"Welcome to DooDoo's Digital Garden","links":[],"tags":[],"content":"이 페이지는 제텔카스텐 기법을 준수하여 옵시디언에서 작성되었습니다.\n전체 두뇌 연결 §\n\n\n                  \n                  Warning \n                  \n                \n추후 구현 예정\n\n\n\n                  \n                  Tip \n                  \n                \nGitHub Pages에 Quartz를 배포하고 관리하는 방법은 quartz 4.0와 Quartz v4를 참고\n\n\n\n                  \n                  추후 구현 기능 예정 \n                  \n                  \n                \n                \n\nTags 만 모아서 보기 (현재 태그를 누르면 tag의 글들이 보임) &gt;&gt; 취소 그래프 뷰가 더러워 질 수 있음\n\n"}}